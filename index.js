const core = require("@actions/core");
const github = require("@actions/github");
const fs = require("fs");
const { resolve } = require("path");
const simpleGit = require("simple-git");
const isBinaryFileSync = require("isbinaryfile").isBinaryFileSync;
const process = require("process");

{
	let eventName = github.context.eventName;
	if (eventName.startsWith("pull_request")) {
		console.log(`Event name: ${eventName}. There's nothing here yet.`);
		return;
	}
}

const githubToken = process.argv[2];
const jobType = process.argv[3];

const githubAccess = `https://x-access-token:${githubToken}@github.com/`;

class UserAgent {
	constructor() {
		let numberRegExp = "[0-9]+.[0-9]+.[0-9]+.[0-9]+";
		this.userAgentRegExp = new RegExp("Chrome/" + numberRegExp, "g");

		let versionRegExp = new RegExp(numberRegExp, "g");
		let fullVersion = require("child_process")
			.execSync("google-chrome --version");

		let nonReducedVersion = versionRegExp.exec(fullVersion);
		if (!nonReducedVersion) {
			process.exit(1);
		}
		let major = /\d+/.exec(nonReducedVersion);
		this.version = `${major}.0.0.0`;
		console.log(`Current version: ${this.version}.`);
	}

	replace(stringData) {
		return stringData.replace(
			this.userAgentRegExp,
			`Chrome/${this.version}`);
	}

	commitMessage() {
		return `Update User-Agent for DNS to Chrome ${this.version}.`;
	}

	branchName() {
		return `chrome_${this.version}`;
	}
};

class LicenseYear {
	constructor() {
		let d = new Date();
		this.year = d.getFullYear();
	}

	replace(stringData) {
		let previousYear = this.year - 1;
		let pattern = `copyright (c) 2014-${previousYear}`;
		return (stringData.toLowerCase().indexOf(pattern) >= 0)
			? stringData.replace(`2014-${previousYear}`, `2014-${this.year}`)
			: stringData;
	}

	commitMessage() {
		return `Update copyright year to ${this.year}.`;
	}

	branchName() {
		return `copyright_to_${this.year}`;
	}
};

class DevToMaster {
	constructor() {
		this.sourceBranch = "dev";
		this.targetBranch = "master";
	}

	replace(stringData) {
		return stringData; // No file modifications needed for merging.
	}

	commitMessage() {
		return `Merge ${this.sourceBranch} into ${this.targetBranch}`;
	}

	branchName() {
		return this.sourceBranch; // Use dev branch directly
	}

	prTitle() {
		return `Merge ${this.sourceBranch} into ${this.targetBranch}`;
	}

	async getLastCommits(repoPath) {
		const git = simpleGit(repoPath);
		const [devCommit, masterCommit] = await Promise.all([
			git.raw(['rev-parse', 'origin/dev']).then(hash => hash.trim()),
			git.raw(['rev-parse', 'origin/master']).then(hash => hash.trim())
		]);
		return { devCommit, masterCommit };
	}

	async prBody(repoPath) {
		const date = new Date().toISOString().split('T')[0];
		const { devCommit, masterCommit } = await this.getLastCommits(repoPath);
		return `` +
			   `This PR merges all latest changes from \`${this.sourceBranch}\` branch into \`${this.targetBranch}\`.\n\n` +
			   `### ðŸ“‹ Details\n` +
			   `- **Source:** \`${this.sourceBranch}\` (${devCommit.substring(0, 7)}).\n` +
			   `- **Target:** \`${this.targetBranch}\` (${masterCommit.substring(0, 7)}).\n` +
			   `- **Generated:** ${date}.\n` +
			   `---\n*ðŸ¤– Automatically generated by GitHub Action*.`;
	}
};

const updater = (() => {
	switch (jobType) {
		case "license-year":
			return new LicenseYear();
		case "user-agent":
			return new UserAgent();
		case "dev-to-master":
			return new DevToMaster();
		default:
			return undefined;
	}
})();

if (!updater) {
	console.log("Job type not found.");
	return;
}

//////

const cloneGit = info => {
	return simpleGit().clone(info.githubRepo)
		.then(() => (new Promise((good, bad) => { good(info); })));
};

const processFiles = info => {
	// For dev-to-master job, skip file processing as we're doing a merge.
	if (jobType === "dev-to-master") {
		return new Promise((good, bad) => { good(info); });
	}

	const readFiles = async dir => {
		const direntsOptions = { withFileTypes: true };
		const dirents = await fs.promises.readdir(dir, direntsOptions);
		const files = await Promise.all(dirents.map(dirent => {
			const res = resolve(dir, dirent.name);
			return dirent.isDirectory() ? readFiles(res) : res;
		}));
		return files.flat().filter(p => (p.indexOf(".git") == -1))
	};

	return readFiles(info.common.repo).then(paths => {
		let modifiedCount = 0;
		paths.forEach(path => {
			const bytes = fs.readFileSync(path);
			const size = fs.lstatSync(path).size;
			if (isBinaryFileSync(bytes, size)) {
				return;
			}
			const original = bytes.toString();
			const modified = updater.replace(original);
			if (original != modified) {
				if (modifiedCount == 0) {
					console.log("Modified files:");
				}
				console.log(path);
				fs.writeFileSync(path, modified);
				modifiedCount++;
			}
		});
		return new Promise((good, bad) => {
			if (modifiedCount == 0) {
				bad("No modified files.");
			} else {
				good(info);
			}
		});
	});
};

const processGit = info => {
	const git = simpleGit(info.common.repo);
	const url = info.githubRepo;
	const commit = updater.commitMessage();
	const branch = updater.branchName();

	return new Promise((good, bad) => {
		git.branch().then(branches => {
			info.baseBranch = branches.current;

			if (jobType !== "dev-to-master"
				&& !branches.all.every((b) => (!b.includes(branch)))) {
				bad("Our branch already exists.");
				return;
			}

			if (jobType === "dev-to-master") {
				info.baseBranch = "master";
				console.log("Preparing dev-to-master merge PR.");
				good(info);
			} else {
				git.remote(["set-url", "origin", url])
					.addConfig("user.name", "GitHub Action")
					.addConfig("user.email", "action@github.com")
					.checkoutLocalBranch(branch)
					.add(".")
					.commit(commit)
					.log((err, log) => {
						if (log.latest.message == commit) {
							git.push(["-u", "origin", branch]).then(() => {
								console.log(
									`Commit message: ${log.latest.message}`);
								good(info);
							});
						} else {
							bad();
						}
					});
			}
		});
	});
};

const processPullRequest = async info => {
	const octokit = github.getOctokit(githubToken);

	// Check if PR already exists.
	try {
		const response = await octokit.rest.pulls.list(info.common);
		const branchName = updater.branchName();
		const existingPR = response.data.find(i => 
			i.head.ref === branchName && i.base.ref === info.baseBranch
		);

		if (!existingPR) {
			const prBody = updater.prBody 
				? (typeof updater.prBody === 'function' && updater.prBody.constructor.name === 'AsyncFunction'
					? await updater.prBody(info.common.repo)
					: updater.prBody())
				: "";

			const prData = {
				title: updater.prTitle
					? updater.prTitle()
					: updater.commitMessage(),
				body: prBody,
				head: branchName,
				base: info.baseBranch,
				...info.common
			};

			const r = await octokit.rest.pulls.create(prData);
			console.log("Pull request is created.");
			console.log(`PR Title: ${prData.title}`);
			console.log(`PR URL: ${r.data.html_url}`);
		} else {
			console.log("Pull request with this branch already exists.");
			console.log(`Existing PR: ${existingPR.html_url}`);
		}
	} catch (error) {
		console.error(error);
	}
};

const createInfo = (owner, repo) => ({
	common: {
		owner: owner,
		repo: repo,
	},
	githubRepo: `${githubAccess}${owner}/${repo}.git`,
	baseBranch: "",
});

const processJob = info => {
	cloneGit(info)
	.then(processFiles)
	.then(processGit)
	.then(async (info) => await processPullRequest(info))
	.catch(error => {
		console.error("Error:", error);
		process.exit(1);
	});
};

processJob(createInfo(github.context.repo.owner, github.context.repo.repo));
